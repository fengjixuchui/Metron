{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\ltrch\loch {\f0\fs22\b0\i0 ## Some Background, And A Big Caveat}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 A lot of my best ideas started out sounding really dumb.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 I\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92ve been a professional programmer for a bit over 25 years now. In that time I\u8217\'92ve worked at pretty much all levels of both the hardware and software tech stacks, from WebGL to embedded assembly code to PCB design and bringup. About 10 years ago I started thinking about a question I couldn\u8217\'92t find a good answer to - \u8220\'93What would it look like for time itself to be a first-class entity in a programming language?\u8221\'94}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 Since I am not a computer scientist, I wasn\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t quite sure where to start looking for an answer. I skimmed all over the Wikipedia pages for programming languages and paradigms, browsed techy subreddits and various other forums, wrote a few toy programming languages that didn\u8217\'92t go anywhere, and eventually decided that I should learn Verilog and try building things for a FPGA. That led to me writing and testing a few CPU cores, which led to me looking into FPGA-based game console emulators, which led to me writing MetroBoy and GateBoy and LogicBoy and all the other Game Boy stuff that\u8217\'92s up on Github. At some point I realized that I wanted a tool to translate some of that code into Verilog, so I wrote Metron and built a live online demo and tutorial for it (also on Github).}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 And all that, in turn, led to me rethinking my original question. What if the right way to get \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93time\u8221\'94 into a programming language wasn\u8217\'92t to try and cram it into the syntax or type system, but to define it as a sort of design pattern? We keep seeing the \u8220\'93atomically change old state into new state\u8221\'94 pattern repeating across a lot of different programming contexts, so what if a programming language made that pattern easier or clearer to express? Surely someone had already done that, coined a term for it, and written a bunch of papers about it? After more Wikipedia and Scholar searches I still didn\u8217\'92t have a solid answer - many articles seemed to describe things _like_ what I was thinking of, but none of them generalized their ideas into something I could point at and say \u8220\'93Yes, that is the umbrella term for describing how time interacts with a programming language that I\u8217\'92ve been looking for\u8221\'94.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 So I\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92m left with coining a term, something more elegant than \u8220\'93atomically change old state into new state\u8221\'94 that can apply equally well to both a game\u8217\'92s state-machine-based AI and a Verilog barrel shifter. In honor of Leslie Lamport\u8217\'92s paper \u8220\'93The Temporal Logic of Actions\u8221\'94, I propose we call it \u8220\'93Temporal Programming\u8221\'94.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 Again, I am not a computer scientist. It\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s quite possible that what I\u8217\'92m describing is an old research topic hidden in some corner of the internet that somehow I\u8217\'92m unable to find on Google Scholar. I\u8217\'92m not \u8220\'93inventing\u8221\'94 a programming paradigm here, just putting a label on something that already exists - if there\u8217\'92s already a term that fits better than \u8220\'93Temporal Programming\u8221\'94, then we should use it instead.}
\par\plain \f0\fs22\b0\i0}