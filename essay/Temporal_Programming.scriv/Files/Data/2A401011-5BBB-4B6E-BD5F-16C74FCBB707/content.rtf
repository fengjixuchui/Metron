{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\ltrch\loch {\f0\fs22\b0\i0 Now for a bit of a conceptual leap - This model of computation as used in Lamport's "Temporal Logic of Actions" _is_ a programming paradigm. It's not a complicated one, but it's distinctly different from the "state changes incrementally" style of imperative programming and the "state doesn't change" style of functional programming. You can also think of it as a reformulation of Synchronous Programming - one that focuses on "all state changes simultaneously" instead of "lots of things happen simultaneously".}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 It's also not at all new - it's the programming paradigm that folks who write code for FPGAs all day think in by default. It's also a paradigm that most software developers _don't_ think in by default, which is part of why Verilog and VHDL can seem so incomprehensible at first. It's a paradigm that a lot of us use every day, but we're so implicitly familiar with it our different sub-areas of programming that we don't really have a word for it at a global level.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 In honor of Leslie Lamport's work on temporal logic, I propose we call it "Temporal Programming".}
\par\plain \f0\fs22\b0\i0}