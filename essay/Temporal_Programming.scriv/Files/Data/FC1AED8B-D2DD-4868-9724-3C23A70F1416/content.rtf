{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \ltrch\loch {\f0\fs22\b0\i0 ## What defines a programming paradigm?}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 ### It should provide a concise but abstract conceptual model}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 A good programming paradigm should be explainable in a few sentences and should provide an answer to the general question of \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93What is programming?\u8221\'94 without referring to concrete details like language, syntax, or implementation.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 For imperative programs, that would be Turing machines. For functional programming, lambda calculus. For temporal programming, recurrence relations}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 ### It should be practical and useful}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 A good programming paradigm should be demonstrable using the tools we already have, even if those tools aren\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t yet}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 ### It should extend our ability to think about programming}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 If it\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s worth calling a paradigm, it should be profound enough that it gives us new ways to think about and solve programming problems. It should add \u8220\'93new tools to the toolbox\u8221\'94 that don\u8217\'92t exist in other paradigms.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0     x' = f(x)}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Structural\u8221\'94 and \u8220\'93Procedural\u8221\'94 programming extended imperative programming by providing ways to simplify programs by clarifying control flow and allowing programs to be split into collections of sub-procedures. \u8220\'93Object-Oriented\u8221\'94 programming extended that further by describing programs as collections of \u8220\'93things\u8221\'94 that can perform \u8220\'93actions\u8221\'94 at a higher level of abstraction.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 Functional programming gave us an alternate definition of programming, one based on applying and composing functions (link to wikipedia) }
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 Temporal programming can be seen as a sort of \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93imperative programming rotated 90 degrees through time\u8221\'94 - instead of modeling a program as a blob of data we call \u8220\'93state\u8221\'94 that is incrementally modified by a sequence of actions over time, temporal programs consist of sequences of \u8220\'93states\u8221\'94 placed at discrete points in time, each computed from the previous state in a single atomic action.}
\par\plain \f0\fs22\b0\i0
\par\pard\plain \tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\ltrch\loch {\f0\fs22\b0\i0 Pure temporal programs transform old states into new states using pure functions.}
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0}