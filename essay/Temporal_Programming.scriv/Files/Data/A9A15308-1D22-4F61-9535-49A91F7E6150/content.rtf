{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\ltrch\loch {\f0\fs22\b0\i0 "Your definition of temporal programming is going to waste instructions recomputing things that haven't changed"}
\par\plain {\f0\fs22\b0\i0    Yes and no. The trivial implementation wastes cycles, a "smart" compiler could save cycles.}
\par\plain {\f0\fs22\b0\i0    But "smart" may not actually be necessary. Simple TP runs fast enough for basic realtime tasks.}
\par\plain {\f0\fs22\b0\i0 Sensitivity lists are an optimization}
\par\plain {\f0\fs22\b0\i0 Synchronous programming seems like trying to cram the synchronous abstraction into an imperative or functional language}
\par\plain {\f0\fs22\b0\i0 The farther you get from pure temporal, the more work it is to translate to hardware}
\par\plain \f0\fs22\b0\i0}