{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \ltrch\loch {\f0\fs22\b0\i0 ## So what would a \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93pure\u8221\'94 temporal programming language look like?}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 The _entire_ program state is X}
\par\plain {\f0\fs22\b0\i0 State changes atomically}
\par\plain {\f0\fs22\b0\i0 Type can change atomically}
\par\plain {\f0\fs22\b0\i0 Code can run backwards if F is invertible}
\par\plain {\f0\fs22\b0\i0 Order of expressions is mostly irrelevant. Temporal programs can be \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93flattened\u8221\'94 into a list of \u8220\'93field\u8217\'92 = f(state)\u8221\'94 expressions}
\par\plain {\f0\fs22\b0\i0 In a temporal programming language, the physical structure of the code (call trees, etc) is less relevant. Statements in a block are order-invariant. Branches select blocks for evaluation but there is no \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93program counter\u8221\'94 in the usual sense}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 A ring oscillator can\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t be modeled directly in temporal programming as it has no clock and is not a pure function}
\par\plain {\f0\fs22\b0\i0 What could a temporal programming language do that \{lang\} can\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t?}
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 Explicitly referring to past and future state}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93The value of X three cycles before Y exceeded 12\u8221\'94}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 We should be able to write arbitrary statements about past and future events and the compiler should be able to figure it out.}
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Is it possible to get to a state with property X from the current state?\u8221\'94}
\par\plain {\f0\fs22\b0\i0 Does property X hold in all possible states?}
\par\plain {\f0\fs22\b0\i0 Tla+ type proof stuff}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 Speculative execution and runahead}
\par\plain {\f0\fs22\b0\i0     Some game console emulators improve responsiveness and input latency by implementing \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93runahead\u8221\'94 - given an \u8220\'93old\u8221\'94 emulation state, they compute every possible \u8220\'93next\u8221\'94 state that could be reached by the user pressing some combination of input buttons. Once the user input is known the emulator can immediately switch to the selected pre-computed state, display the corresponding game image, and then begin computing the next set of possible states.}
\par\plain {\f0\fs22\b0\i0     This is not right }{\field{\*\fldinst HYPERLINK "https://docs.libretro.com/guides/runahead"}{\fldrslt\f0\fs22\b0\i0 https://docs.libretro.com/guides/runahead}}{\f0\fs22\b0\i0 /}
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 ## Open Questions}
\par\plain {\f0\fs22\b0\i0  - What do statements like \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93x@-2 = y@+3\u8221\'94 even mean?}
\par\plain {\f0\fs22\b0\i0  - A sufficiently smart compiler doesn\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t need to keep as many intermediate copies}
\par\plain {\f0\fs22\b0\i0  - Large programs are expression graphs that can be incrementally evaluated in parallel by a \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93swarm\u8221\'94 of worker bees}
\par\plain {\f0\fs22\b0\i0  - What would a processor designed specifically for temporal programs look like? Something in between a CPU and a FPGA?}
\par\plain {\f0\fs22\b0\i0  - \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Programming Paradigms for Dummies: What Every Programmer Should Know\u8221\'94}
\par\plain {\f0\fs22\b0\i0  - \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93discrete synchronous programming\u8221\'94}
\par\plain {\f0\fs22\b0\i0  - In this paradigm, a program waits for input events, does internal calculations, and emits output events}
\par\plain {\f0\fs22\b0\i0  - \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Waits\u8221\'94 is meaningless in TPL}
\par\plain {\f0\fs22\b0\i0  - Doesn\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t discuss internal state change}
\par\plain {\f0\fs22\b0\i0  - \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93output events from one subcomponent are instantaneously available as input events in other subcomponents\u8221\'94}
\par\plain {\f0\fs22\b0\i0      - Well, not exactly. }
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0}