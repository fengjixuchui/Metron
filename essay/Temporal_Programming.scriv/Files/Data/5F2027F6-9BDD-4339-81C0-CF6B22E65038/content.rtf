{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \ltrch\loch {\f0\fs22\b0\i0 ## Temporal Programming and Concurrency}
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Concurrency\u8221\'94 is irrelevant at the language level. }
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Concurrent programming would be much simpler if the nondeterminism were controlled in some way, so that it is not visible to the programmer.\u8221\'94 - Van Roy}
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93For example, if each of two threads assigns a variable cell to a different value, then each of the two values can be observed:\u8221\'94}
\par\plain {\f0\fs22\b0\i0    This cannot be expressed in a temporal programming language - by definition a variable can have only one future}
\par\plain {\f0\fs22\b0\i0 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93concurrency naturally implies nondeterminism.\u8221\'94}
\par\plain {\f0\fs22\b0\i0    No it doesn\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t, not in this context}
\par\plain \f0\fs22\b0\i0}